/*
 * real_time_clock_ATmega8.c
 *
 * Created: 06.02.2021 22:35:35
 * Author : admin
 */ 



/* 
 * Программа электронных часов 
 * на асинхронном таймере счетчике ТС2 
 * для МК АТмега8 с выводом времени на семисигментный индикатор
 */


#define F_CPU 4000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define  blink_led 2

void _7SEG_indikator ();
void setup_ports (void);
void PCK_mode_T2 (void); 
int hours ( unsigned long h);
int minutes (unsigned long h);
void razbika (unsigned long chislo_1, unsigned long chislo_2);

 // Массив чисел от 0 до 9 для семисигментного индикатора без точки
unsigned char number [10] = {
	0x3F, // 0
	0x6,  // 1
	0x5B, // 2
	0x4F, // 3
	0x66, // 4
	0x6D, // 5
	0x7D, // 6
	0x07, // 7
	0x7F, // 8
	0x6F  // 9
};

 // Массив чисел от 0 до 9 для семисигментного индикатора с точкой
unsigned char number_point [10] =
{
	0xBF, // 0
	0x86, // 1
	0xDB, // 2
	0xCF, // 3
	0xE6, // 4
	0xED, // 5
	0xFD, // 6
	0x87, // 7
	0xFF, // 8
	0xEF  // 9
};

unsigned char hour = 0;
unsigned char minute = 0;
unsigned long second = 0;

unsigned char segment_1 = 0;
unsigned char segment_2 = 0;
unsigned char segment_3 = 0;
unsigned char segment_4 = 0;

unsigned char point = 1;



ISR (TIMER2_COMP_vect) //Вектор прерывания для ТС2. инкриментируем переменную seconds каждый заход в вектор до тех пор пока она не будет больше 60
{
	second ++; //Данная переменная хранит общее количество секунд. Раз всекунду происходит инкремент переменной
	
	//PORTC ^= 1<<PC5;
	
	if (point != 1) //С помощью данной конструкции if зажигаем раз в секнду точку на втором семисегментном индикаторе
	{
		point = 1;
	}
	else point = 2;
}



int main(void) // Начало основной функции main
{

	setup_ports(); // Настройка портов ввода / вывода
	
	PCK_mode_T2(); // Настройка T2 в асинхронный режим
	
    while (1) //Начало основного цикла
    {
		razbika(minutes(second), hours(second)); //В данную функцию передаем накопленные секунды для пересчета их в часы и минуты
		
		_7SEG_indikator(); //Функция вывода времени на семисегментный индикатор
		
		if (~PINC & (1<<PC1)) // Начало настройки часов. Нажатие на кнопку добавляет по одному часу
		{
			second = second + 3600;
			
			while(~PINC & (1<<PC1));
		} // Конец настройки часов
		
		if (~PINC & (1<<PC2)) // Начало настройки минут. Нажати на кнопку добавляет по одной минуте
		{
			second = second + 60;
			
			while(~PINC & (1<<PC2));
		} // Конец настройки минут
		
		if (second > 86400) // В сутках 86400 секунд. При переполнении сбрасываем секнды в ноль. 
		{
			second = 0;
		}
    } //Конец основного цикла
} //Конец основной функции main

/*********************Функция настройки портов ввода вывода*****************************/

void setup_ports (void) //Начало функции
{
	    PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0));
	    DDRB |= (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0);
	    
	    PORTD = 0x00;
	    DDRD = 0xFF;
	    
	    PORTC |= (1<<PC4)|(1<<PC3)|(1<<PC2)|(1<<PC1)|(1<<PC0);
		PORTC &= ~(1<<PC5);
	    DDRC &= ~((1<<PC4)|(1<<PC3)|(1<<PC2)|(1<<PC1)|(1<<PC0));
		DDRC |= (1<<PC5);
} //Конец функции

/*********************Функция настройки второго таймра / счетчика на асинхронный режим работы*****************************/

void PCK_mode_T2 (void) //Начало функции
{
	asm("cli"); // Глобальный запрет прерываний
	
	ASSR |= (1<<AS2); // Активация асинхронного режима ТС2
	
	while(ASSR != (0b00001000)) // Проверка состояния битов регистра ASSR для безопасной записи данных в остальные регистры ТС2. Все биты кроме 4-го должны быть в ноле
	
	{
		asm("nop"); // Повисаем в цикле пока биты в регистре ASSR не примут требуемое состояние. 
	}
	
	TCCR2 |= (1<<WGM21); // Режим СТС. Сброс при совпадении
	TCCR2 &= ~(1<<WGM20);
	TCCR2 |= (1<<CS22)|(1<<CS20); // Делитель таймера 256 для получения интервала в 1 секунду
	OCR2 = 255; // Чило для регистра сравнения. При совпадении с которым программа перейдет в вектор прерывания
	TIMSK |= (1<<OCIE2); // Разрешение прерывания
	TIFR = 0; // Сброс флагов прерывания
	SFIOR |= (1<<PSR2); // Обнуление предделителя
	TCNT2 = 0; // Сброс счетного регистра
	
	
	asm("sei"); // Глобальное разрешение прерываний
	
} //Конец функции

/**************************Функция расчитывает минуты из накопленных секунд***********************************/
int hours (unsigned long h) //Начало функции
{
	h = ((h / 60) / 60);
	return h;
} //Конец функции


/**************************Функция расчитывает часы из накопленных секунд***********************************/
int minutes (unsigned long m) //Начало функции
{
	m = ((m / 60) % 60);
	
	return m;
}//Конец функции


/**************************Функция разбивает числа на цифры***********************************/
void razbika (unsigned long chislo_1, unsigned long chislo_2) //Начало функции
{
	segment_1 = chislo_1 % 10;
	segment_2 = chislo_1 / 10;
	
	segment_3 = chislo_2 % 10;
	segment_4 = chislo_2 / 10;
} //Конец функции


/**************************Функция вывода времени на семисегментные индикаторы***********************************/
void _7SEG_indikator (void) //Начало функции
{
			PORTD = 0x00; //Четвертая цифра
			PORTD = number[segment_1];
			PORTB = 0b1000;
			_delay_ms(blink_led);
			
			PORTD = 0x00; //Третья цифра
			PORTD = number[segment_2];
			PORTB = 0b0100;
			_delay_ms(blink_led);
			
			PORTD = 0x00; //Вторая цифра без точки
			if (point == 1)
			{
				PORTD = number[segment_3];
			}
			
			else  {PORTD = number_point[segment_3];}
			PORTB = 0b0010; //Вторая цифра с точкой
			_delay_ms(blink_led);
			
			PORTD = 0x00; //Первая цифра
			PORTD = number[segment_4];
			PORTB = 0b0001;
			_delay_ms(blink_led);
} //Конец функции



/*
 * real_time_clock_ATmega8.c
 *
 * Created: 06.02.2021 22:35:35
 * Author : admin
 */ 

/* 
 * Программа электронных часов 
 * на асинхронном таймере счетчике ТС2 
 * для МК АТмега8 с выводом времени на семисигментный индикатор
 */


#define F_CPU 4000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define  button_delay 30 //Задержка срабатывания нажатых кнопок, настройки "Часов" и "Минут". Величина в "попугаях", зависит от срабатывания прерывания ТС0

void _7SEG_indikator (void);
void setup_ports (void);
void PCK_mode_T2 (void); 
int hours (unsigned long h);
int minutes (unsigned long h);
void razbika (unsigned long chislo_1, unsigned long chislo_2);
void button (void);
void TC0_setup (void); 
void button_touch_delay (void);

 // Массив чисел от 0 до 9 для семисигментного индикатора без точки
unsigned char number [10] = {
	0x3F, // 0
	0x6,  // 1
	0x5B, // 2
	0x4F, // 3
	0x66, // 4
	0x6D, // 5
	0x7D, // 6
	0x07, // 7
	0x7F, // 8
	0x6F  // 9
};

 // Массив чисел от 0 до 9 для семисигментного индикатора с точкой
unsigned char number_point [10] =
{
	0xBF, // 0
	0x86, // 1
	0xDB, // 2
	0xCF, // 3
	0xE6, // 4
	0xED, // 5
	0xFD, // 6
	0x87, // 7
	0xFF, // 8
	0xEF  // 9
};

unsigned char hour = 0;
unsigned char minute = 0;
unsigned long second = 0;

unsigned char segment_1 = 0;
unsigned char segment_2 = 0;
unsigned char segment_3 = 0;
unsigned char segment_4 = 0;
unsigned char segment_number = 1;

unsigned char point = 1;

unsigned char time_setup = 0;

unsigned char button_hour = 0;
unsigned char button_minute = 0;

ISR (TIMER0_OVF_vect)
{
	segment_number++;
	
	if (segment_number >= 5)
	{
		segment_number = 1;
	}
	
	button_touch_delay(); //Задержка срабатывания кнопок для настройки "Часов" и "Минут"
	
	button(); //Функция обработки кнопок настройки часов
	
	TCNT0 = 178; //Записываем число 178 в регистр TCNT0, для получения интервала 2мс. Это интервал срабатывания прерывания по переполнению ТС0
}

ISR (TIMER2_COMP_vect) //Вектор прерывания для ТС2. инкриментируем переменную seconds каждый заход в вектор до тех пор пока она не будет больше 60
{
	second ++; //Данная переменная хранит общее количество секунд. Раз всекунду происходит инкремент переменной
	
	if (point != 1) //С помощью данной конструкции if зажигаем раз в секнду точку на втором семисегментном индикаторе
	{
		point = 1;
	}
	else point = 2;
}

int main(void) // Начало основной функции main
{

	setup_ports(); // Настройка портов ввода / вывода
	
	PCK_mode_T2(); // Настройка T2 в асинхронный режим
	
	TC0_setup(); // Запуск ТС0
	
    while (1) //Начало основного цикла
    {
		razbika(minutes(second), hours(second)); //В данную функцию передаем накопленные секунды для пересчета их в часы и минуты
		
		_7SEG_indikator(); //Функция вывода времени на семисегментный индикатор
		
		if (second > 86400) // В сутках 86400 секунд. При переполнении сбрасываем секнды в ноль. 
		{
			second = 0;
		}
    } //Конец основного цикла
} //Конец основной функции main

/*********************Функция настройки портов ввода вывода*****************************/

void setup_ports (void) //Начало функции
{
	    PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0));
	    DDRB |= (1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0);
	    
	    PORTD = 0x00;
	    DDRD = 0xFF;
	    
	    PORTC |= (1<<PC4)|(1<<PC3)|(1<<PC2)|(1<<PC1)|(1<<PC0);
		PORTC &= ~(1<<PC5);
	    DDRC &= ~((1<<PC4)|(1<<PC3)|(1<<PC2)|(1<<PC1)|(1<<PC0));
		DDRC |= (1<<PC5);
} //Конец функции

/*********************Функция настройки второго таймра / счетчика на асинхронный режим работы*****************************/

void PCK_mode_T2 (void) //Начало функции
{
	asm("cli"); // Глобальный запрет прерываний
	
	ASSR |= (1<<AS2); // Активация асинхронного режима ТС2
	
	while(ASSR != (0b00001000)) // Проверка состояния битов регистра ASSR для безопасной записи данных в остальные регистры ТС2. Все биты кроме 4-го должны быть в ноле
	
	{
		asm("nop"); // Повисаем в цикле пока биты в регистре ASSR не примут требуемое состояние. 
	}
	
	TCCR2 |= (1<<WGM21); // Режим СТС. Сброс при совпадении
	TCCR2 &= ~(1<<WGM20);
	TCCR2 |= (1<<CS22)|(1<<CS20); // Делитель таймера 256 для получения интервала в 1 секунду
	OCR2 = 255; // Чило для регистра сравнения. При совпадении с которым программа перейдет в вектор прерывания
	TIMSK |= (1<<OCIE2); // Разрешение прерывания
	TIFR = 0; // Сброс флагов прерывания
	SFIOR |= (1<<PSR2); // Обнуление предделителя
	TCNT2 = 0; // Сброс счетного регистра
	
	
	asm("sei"); // Глобальное разрешение прерываний
	
} //Конец функции

/**************************Функция расчитывает минуты из накопленных секунд***********************************/
int hours (unsigned long h) //Начало функции
{
	h = ((h / 60) / 60);
	return h;
} //Конец функции

/**************************Функция расчитывает часы из накопленных секунд***********************************/
int minutes (unsigned long m) //Начало функции
{
	m = ((m / 60) % 60);
	
	return m;
}//Конец функции

/**************************Функция разбивает числа на цифры***********************************/
void razbika (unsigned long chislo_1, unsigned long chislo_2) //Начало функции
{
	segment_1 = chislo_1 % 10;
	segment_2 = chislo_1 / 10;
	
	segment_3 = chislo_2 % 10;
	segment_4 = chislo_2 / 10;
} //Конец функции

/**************************Функция вывода времени на семисегментные индикаторы***********************************/
void _7SEG_indikator (void) //Начало функции
{
	switch (segment_number) //Начало оператора switсh
	{
		case 1: 
			PORTD = 0x00; //Четвертая цифра
 			PORTD = number[segment_1];
 			PORTB = 0b1000;
			break;
			 
		case 2:
			PORTD = 0x00; //Третья цифра
			PORTD = number[segment_2];
			PORTB = 0b0100;
			break;
						
		case 3:
			PORTD = 0x00; //Вторая цифра без точки
			
			if (point == 1)
			{
				PORTD = number[segment_3];
			}
			else PORTD = number_point[segment_3];

			PORTB = 0b0010; //Вторая цифра с точкой
			break;
						
		case 4:
			PORTD = 0x00; //Первая цифра
			PORTD = number[segment_4];
			PORTB = 0b0001;	
			break;							
	} //Конец оператора switсh

} //Конец функции

/**************************Функция обработки кнопок настройки часов***********************************/
void button (void) //Начало функции
{
			if (button_hour == button_delay) // Начало настройки часов. Нажатие на кнопку добавляет по одному часу
			{
				second = second + 3600;
			} // Конец настройки часов
			
			if (button_minute == button_delay) // Начало настройки минут. Нажати на кнопку добавляет по одной минуте
			{
				second = second + 60;
			} // Конец настройки минут
} //Конец функции

/**************************Функция настрйки ТС0***********************************/
void TC0_setup (void) //Начало функции
{
	TCCR0 |= (1<<CS02); //Предделитеь настроен на 256
	TIMSK |= (1<<TOIE0); // Разрешаем прерывание на переполнению 
	TCNT0 = 178; //Число в регистре с которого начинается счет чтобы получить 2мс
} //Конец функции

/**************************Функция реализует задержку смены цифры при настройке "Часов" и "Минут"***********************************/
void button_touch_delay (void) //Начало функции
{
		if (~PINC & (1<<PC1)) //Задержка срабатывания кнопки, настройки "Часов"
		{
			button_hour ++; //Переменнах хоанит задержку для настройки "Часов"
		}
		else button_hour = 0;
		
		if (button_hour > button_delay)  //Обнуление переменной хранящей задержку "Часов" если кнопка настройки не нажата 
		{
			button_hour = 0;
		}
		
		if (~PINC & (1<<PC2)) //Задержка срабатывания кнопки, настройки "Минут"
		{
			button_minute ++; //Переменнах хоанит задержку для настройки "Минут"
		}
		else button_minute = 0;
		
		if (button_minute > button_delay)  //Обнуление переменной хранящей задержку "Минут" если кнопка настройки не нажата 
		{
			button_minute = 0;
		}
} //Конец функции